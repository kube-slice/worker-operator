diff --git a/api/v1beta1/slice_types.go b/api/v1beta1/slice_types.go
index 8a51780b..f4ba95ac 100644
--- a/api/v1beta1/slice_types.go
+++ b/api/v1beta1/slice_types.go
@@ -73,6 +73,8 @@ type SliceConfig struct {
 	SliceGatewayServiceType string `json:"sliceGatewayServiceType,omitempty"`
 	// SliceGateway Protocol Type: UDP or TCP
 	SliceGatewayProtocol string `json:"sliceGatewayProtocol,omitempty"`
+	// Slice overlay network deployment mode: single-network or multi-network
+	SliceOverlayNetworkDeploymentMode string `json:"sliceOverlayNetworkDeploymentMode,omitempty"`
 }
 
 // NamespaceIsolationProfile defines the namespace isolation policy for the slice
diff --git a/config/crd/bases/networking.kubeslice.io_slices.yaml b/config/crd/bases/networking.kubeslice.io_slices.yaml
index e318ac8b..e6d64c13 100644
--- a/config/crd/bases/networking.kubeslice.io_slices.yaml
+++ b/config/crd/bases/networking.kubeslice.io_slices.yaml
@@ -183,6 +183,10 @@ spec:
                     required:
                     - sliceIpamType
                     type: object
+                  sliceOverlayNetworkDeploymentMode:
+                    description: 'Slice overlay network deployment mode: single-network
+                      or multi-network'
+                    type: string
                   sliceSubnet:
                     description: IP subnet range of the slice.
                     type: string
diff --git a/controllers/slicegateway/slicegateway.go b/controllers/slicegateway/slicegateway.go
index 6016d9c9..5ccfb0da 100644
--- a/controllers/slicegateway/slicegateway.go
+++ b/controllers/slicegateway/slicegateway.go
@@ -260,6 +260,7 @@ func (r *SliceGwReconciler) deploymentForGatewayServer(g *kubeslicev1beta1.Slice
 							"/etc/openvpn/openvpn.conf",
 							"90",
 							"ovpn_run",
+							"--proto " + strings.ToLower(g.Status.Config.SliceGatewayProtocol),
 						},
 						SecurityContext: &corev1.SecurityContext{
 							Privileged:               &privileged,
@@ -1375,6 +1376,20 @@ func (r *SliceGwReconciler) ReconcileGatewayDeployments(ctx context.Context, sli
 		}
 	}
 
+	// Check if any gw deployment needs to be updated
+	for _, deployment := range deployments.Items {
+		// Check if the gw protocol needs to be updated
+		if gwProtocolInUse(sliceGw, &deployment) != strings.ToLower(sliceGw.Status.Config.SliceGatewayProtocol) {
+			newDep := setProtoInGwDeployment(sliceGw, &deployment, strings.ToLower(sliceGw.Status.Config.SliceGatewayProtocol))
+			err := r.Update(ctx, newDep)
+			if err != nil {
+				log.Error(err, "Failed to update Deployment with proto", "Name", newDep.Name, "NewProto", strings.ToLower(sliceGw.Status.Config.SliceGatewayProtocol))
+				return ctrl.Result{}, err, true
+			}
+			return ctrl.Result{Requeue: true}, nil, true
+		}
+	}
+
 	// Reconcile deployment to node port mapping for gw client deployments
 	if isClient(sliceGw) {
 		for _, deployment := range deployments.Items {
diff --git a/controllers/slicegateway/utils.go b/controllers/slicegateway/utils.go
index aa9c4558..f8b9e49a 100644
--- a/controllers/slicegateway/utils.go
+++ b/controllers/slicegateway/utils.go
@@ -218,6 +218,34 @@ func gwDeploymentIsPresent(sliceGwName string, gwInstance int, deployments *apps
 	return false
 }
 
+func gwProtocolInUse(gw *kubeslicev1beta1.SliceGateway, deployment *appsv1.Deployment) string {
+	if gw.Status.Config.SliceGatewayHostType == "Server" {
+		for _, container := range deployment.Spec.Template.Spec.Containers {
+			if container.Name == "kubeslice-openvpn-server" {
+				protoStr := container.Args[len(container.Args)-1]
+				if len(strings.Split(protoStr, " ")) == len([]string{"--proto", "protocol"}) {
+					return strings.Split(protoStr, " ")[1]
+				}
+			}
+		}
+	}
+
+	return ""
+}
+
+func setProtoInGwDeployment(gw *kubeslicev1beta1.SliceGateway, deployment *appsv1.Deployment, proto string) *appsv1.Deployment {
+	if gw.Status.Config.SliceGatewayHostType == "Server" {
+		for _, container := range deployment.Spec.Template.Spec.Containers {
+			if container.Name == "kubeslice-openvpn-server" {
+				container.Args[len(container.Args)-1] = "--proto " + proto
+				return deployment
+			}
+		}
+	}
+
+	return nil
+}
+
 func getGwDeployment(ctx context.Context, c client.Client, sliceGw *kubeslicev1beta1.SliceGateway, depName string) *appsv1.Deployment {
 	deployments, err := GetDeployments(ctx, c, sliceGw.Spec.SliceName, sliceGw.Name)
 	if err != nil {
diff --git a/pkg/manifest/egress.go b/pkg/manifest/egress.go
index 8963e57b..6d77d74c 100644
--- a/pkg/manifest/egress.go
+++ b/pkg/manifest/egress.go
@@ -43,39 +43,40 @@ import (
 //	gateway
 func InstallEgress(ctx context.Context, c client.Client, slice *kubeslicev1beta1.Slice) error {
 	sliceName := slice.Name
+	templates := map[string]string{"SLICE": sliceName}
 
 	deploy := &appsv1.Deployment{}
-	err := NewManifest("egress-deploy", sliceName).Parse(deploy)
+	err := NewManifest("egress-deploy", templates).Parse(deploy)
 	if err != nil {
 		return err
 	}
 
 	svc := &corev1.Service{}
-	err = NewManifest("egress-svc", sliceName).Parse(svc)
+	err = NewManifest("egress-svc", templates).Parse(svc)
 	if err != nil {
 		return err
 	}
 
 	role := &rbacv1.Role{}
-	err = NewManifest("egress-role", sliceName).Parse(role)
+	err = NewManifest("egress-role", templates).Parse(role)
 	if err != nil {
 		return err
 	}
 
 	sa := &corev1.ServiceAccount{}
-	err = NewManifest("egress-sa", sliceName).Parse(sa)
+	err = NewManifest("egress-sa", templates).Parse(sa)
 	if err != nil {
 		return err
 	}
 
 	rb := &rbacv1.RoleBinding{}
-	err = NewManifest("egress-rolebinding", sliceName).Parse(rb)
+	err = NewManifest("egress-rolebinding", templates).Parse(rb)
 	if err != nil {
 		return err
 	}
 
 	gw := &istiov1beta1.Gateway{}
-	err = NewManifest("egress-gw", sliceName).Parse(gw)
+	err = NewManifest("egress-gw", templates).Parse(gw)
 	if err != nil {
 		return err
 	}
diff --git a/pkg/manifest/file.go b/pkg/manifest/file.go
index 4ce1fcc2..1a2e9250 100644
--- a/pkg/manifest/file.go
+++ b/pkg/manifest/file.go
@@ -42,14 +42,14 @@ func GetManifestPath(file string) string {
 }
 
 type Manifest struct {
-	Slice string
-	Path  string
+	Path      string
+	Templates map[string]string
 }
 
-func NewManifest(f string, slice string) *Manifest {
+func NewManifest(f string, templates map[string]string) *Manifest {
 	return &Manifest{
-		Path:  GetManifestPath(f),
-		Slice: slice,
+		Path:      GetManifestPath(f),
+		Templates: templates,
 	}
 }
 
@@ -60,7 +60,10 @@ func (m *Manifest) Parse(v interface{}) error {
 		return err
 	}
 
-	f := strings.ReplaceAll(string(jsonFile), "SLICE", m.Slice)
+	f := ""
+	for templateKey, templateVal := range m.Templates {
+		f = strings.ReplaceAll(string(jsonFile), templateKey, templateVal)
+	}
 
 	err = json.Unmarshal([]byte(f), v)
 	if err != nil {
diff --git a/pkg/manifest/file_test.go b/pkg/manifest/file_test.go
index 7bd38c1a..dd57865c 100644
--- a/pkg/manifest/file_test.go
+++ b/pkg/manifest/file_test.go
@@ -31,10 +31,11 @@ var _ = Describe("Manifest File", func() {
 	Context("With k8s deployment manifest", func() {
 
 		f := "egress-deploy"
+		templates := map[string]string{"SLICE": "green"}
 
 		It("Should parse file into k8s deployment in the slice", func() {
 
-			m := manifest.NewManifest(f, "green")
+			m := manifest.NewManifest(f, templates)
 
 			Expect(m).ToNot(BeNil())
 
diff --git a/pkg/manifest/ingress.go b/pkg/manifest/ingress.go
index 544bdadc..7328eeba 100644
--- a/pkg/manifest/ingress.go
+++ b/pkg/manifest/ingress.go
@@ -42,39 +42,40 @@ import (
 //	service (type clusterip)
 func InstallIngress(ctx context.Context, c client.Client, slice *kubeslicev1beta1.Slice) error {
 	sliceName := slice.Name
+	templates := map[string]string{"SLICE": sliceName}
 
 	deploy := &appsv1.Deployment{}
-	err := NewManifest("ingress-deploy", sliceName).Parse(deploy)
+	err := NewManifest("ingress-deploy", templates).Parse(deploy)
 	if err != nil {
 		return err
 	}
 
 	svc := &corev1.Service{}
-	err = NewManifest("ingress-svc", sliceName).Parse(svc)
+	err = NewManifest("ingress-svc", templates).Parse(svc)
 	if err != nil {
 		return err
 	}
 
 	role := &rbacv1.Role{}
-	err = NewManifest("ingress-role", sliceName).Parse(role)
+	err = NewManifest("ingress-role", templates).Parse(role)
 	if err != nil {
 		return err
 	}
 
 	sa := &corev1.ServiceAccount{}
-	err = NewManifest("ingress-sa", sliceName).Parse(sa)
+	err = NewManifest("ingress-sa", templates).Parse(sa)
 	if err != nil {
 		return err
 	}
 
 	rb := &rbacv1.RoleBinding{}
-	err = NewManifest("ingress-rolebinding", sliceName).Parse(rb)
+	err = NewManifest("ingress-rolebinding", templates).Parse(rb)
 	if err != nil {
 		return err
 	}
 
 	gw := &istiov1beta1.Gateway{}
-	err = NewManifest("ingress-gw", sliceName).Parse(gw)
+	err = NewManifest("ingress-gw", templates).Parse(gw)
 	if err != nil {
 		return err
 	}
